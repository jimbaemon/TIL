# 도커와 쿠버네티스 시작하기

## 전통적인 방식과, 온프레미스 환경 이해와 단점

#### 모놀리식 아키텍처

![image-20210125235205085](http://www.jimbae.com:59005/image/75)

* 모놀리식은 하나의 어플리케이션으로 만들어서 서비스 하는것 -> 기존의 방식
* 마이크로 서비스는 서비스를 서비스 단위로 어플리케이션을 생성하는 것이다.



#### 모놀리식 아키텍처의 단점

* **스케일링** : 모놀리식 아키텍처를 스케일링시 불필요한 서비스 같이 함꼐 스케일링 해야하는 단점이 존재한다.

![image-20210125235332529](http://www.jimbae.com:59005/image/76)

* **종속적인 라이브러리의 충돌**
  * 각각의 기능들은 서로 다른 기능을 제공하여 버전의 종속성을 필요한 경우가 존재
  * 각 기능의 따른 라이브러리를 매 업데이트마다 관리하기 매우 어렵다.

![image-20210125235540415](http://www.jimbae.com:59005/image/77)

* **조금만 수정해도 전체 빌드 및 배포 필요**
  * 소스코드 전체가 하나로써 동작하기 때문에 작은 수정만 있더라도 전체를 빌드하여 다시 배포해야 함.





## 마이크로서비스를 구현하는 도커와 쿠버네티스

### 마이크로서비스 아키텍처

* 모놀리식 아키텍처의 대안으로 반대되는 개념
* 애플리케이션의 각각의 기능을 분리하여 개발 및 관리
* 마이크로서비스 장점
  * 서비스 단위의 빠른 개발 : 개발자가 특정 비즈니스 로직에 대해서만 집중하여 개발 가능
  * 배포 용이: 개별 서비스 단위로 개발, 패키징, 빌드, 테스트, 배포로 각 서비스마다 유연한 스케쥴
  * 서비스 단위의 Scale-Out 구조: 서비스 단위로 스케일링이 가능하여 불필요한 서비스는 줄이고 더많은 자원이 필요한 서비스는 확장가능.
* **분산 시스템 환경에서 Transaction 보장, 테스트, 배포, 관리가 복잡하다**



#### 모놀리식 라이프 사이클과 마이크로 서비스 라이프 사이클 비교

![image-20210126000425389](http://www.jimbae.com:59005/image/78)



#### 서비스 단위의 Scale-Out 구조

> 필요한 서비스의 한정해서 스케일링후 로드밸런싱 하면 된다.

![image-20210126000551710](http://www.jimbae.com:59005/image/79)



## 네이티브, 컨테이너와 VM 성능 비교

### 컨테이너

* 컨테이너는 가상머신을 사용해 각 마이크로 서비스를 격리(isolate)하는 기술

* 컨테이너는 가상머신처럼 하드웨어를 전부 구현하지 않기 때문에 매우 빠른 실행 가능

* 프로세스의 문제가 발생할 경우 컨테이너 전체를 조정해야 하기 때문에 컨테이너에 하나의 프로세스를 실행하도록 하는 것이 좋다.

  ![container_evolution](http://www.jimbae.com:59005/image/80)

* **Traditional Deployment** : 전통 방식 OS  위에 앱을 실행
* **Virtualized Deployment** : 하드웨어에 Hypervisor 를 이용한 가상화 환경을 구축하여 앱 실행 [무겁다고함]
* **Container Deployment** : OS를 설치할 필요 없고, Hypervisor 를 통해서 가상화를 할필요가 없기 때문에 리소스가 줄고 효율적으로 가상화 환경 운영가능



### 컨테이너를 격리하는 기술

* **리눅스 네임 스페이스** : 각 프로세스가 파일 시스템 마운트, 네트워크, 유저, 호스트 네임 등에 대해 시스템에 독립 뷰를 제공한다.
  * 완전이 격리된 네임 스페이스에서 돌아가기 때문에 상호간의 간섭이 불가능 하다.
  * 커널이나 OS 는 공유한다고 한다 (**의문점 : 윈도우 도커에서는 어떻게 리눅스 환경의 컨테이너가 실행 가능하지? OS 없이**)

![image-20210127231356393](http://www.jimbae.com:59005/image/81)

* **리눅스 컨트롤 그룹** : 프로세스로 소비할 수 있는 리소스 양(CPU, 메모리, I/O, 네트워크 대역대, device 노드 등)을 제한

![image-20210127233354363](http://www.jimbae.com:59005/image/83)

## 도커와 쿠버네티스 소개

### 도커(Docker)

* 컨테이너 기술을 지원하는 다양한 프로젝트 중에 하나
* 컨테이너 기술은 이전에도 있었으나 도커로 인해 알려짐
* 컨테이너 기술의 사실상 표준
* 2014 가장 인기 있는 클라우드 오픈 소스 2위
* 다양한 운영체제에서 사용 가능 (리눅스, 윈도우, MacOS) [위도우는 Hypervisor 위에서 돌아가므로 성능이 떨어짐]
* 애플리케이션에 국한 되지 않고 의존성 및 파일 시스템까지 패키징하여 빌드, 배포, 실행을 단순화
* 리눅스 네임스페이스와 cgroups[컨트롤그룹]와 같은 커널 기능을 사용하여 가상화 

#### 도커의 아키텍처

* Docker engine: 이미지, 네트워크, 디스크 등의 관리 역활
* Containerd: OCI 구현체 (주로 runC)를 이용해 container를 관리해주는 daemon
* 두 프로그램이 각각 돌아가기 때문에 Docker Engine을 시작해도 각 이미지에 영향이 없음

![image-20210128213912476](http://www.jimbae.com:59005/image/84)

#### 도커의 한계

* 서비스가 커지면 커질수록 관리해야 하는 컨테이너의 양이 급격히 증가 [서버가 4 대에 컨테이너가 3개씩만 돌아가도 12개를 관리해줘야한다..]
* 도커를 사용하여 관리를 한다 하더라도 쉽지 않은 형태



## 쿠버네티스

* 2014년 구글이 오픈 소스 공개
* 구글이 컨테이너 운영 노하우가 담긴 오픈소스
* 고대 그리스어로 항해사라는 의미를 가짐
* 다수의 컨테이너를 자동으로 운영하기 위한 오케스트레이션 도구
* 많은 시스템을 통합, 컨테이너를 다루기 위한 API 제공

![image-20210128214403272](http://www.jimbae.com:59005/image/85)



#### 데브옵스(DevOps) 모델

* 데브옵스는 소프트웨어 개발과 IT 운영을 결합한 합성어
* 기존의 분리된 소프트웨어 개발팀과 IT 운영팀의 협업으로 전체 라이프사이클을 함께 관리할 수 있자는 일종의 철학 또는 운동
* 소프트웨어 개발팀과 IT 팀이 더 빠르고 안정적으로 소프트웨어를 빌드, 릴리즈할 수 있도록 두 팀 간의 프로세스를 자동화하는 일련의 과정
* 데브옵스의 이점
  * 상호간 업무적 이해가 빨라 속도가 빨라진다.
  * 신속한 서비스 제공이 가능하다
  * 안전성과 협업이 강화된다.
* 개발자의 관점
  * 새로운 기능을 만들어 사용자 경험을 개선하는 것을 좋아함
  * 기본 운영체제의 보안 패치나 이와 관련된 모든 것이 최신인지 확인하는 것을 시스템 관리자에게 맡기려함. ㅋㅋ
* 시스템 관리자의 장점
  * 제품 배포와 운영하는 하드웨어 인프라를 담당하며 시스템보안, 활용, 개발자의 우선순위가 높지 않은 측면에 신경을 씀
  * 운영 담당자는 모든 애플리케이션 구성 요소의 암묵적 상호 의존성에 대처하기를 원하지 않음 [개쉑히들]
  * 기본 운영체제나 인프라를 변경했을 때 애플리케이션 전체 동작에 어떤 영향을 미칠지는 생가치 못함 [하 노답]

