# 리팩터링 7장

## 서문

책의 저자는 모듈을 분리하는 가장 중요한 기준은 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있다고 알려준다. 

모듈에서 드러나지 않아야 하는 대표중 하니인 **데이터 구조**는 `레코드 캡슐화 하기`<sup>7.1</sup>, `컬렙션 캡슐화하기`<sup>7.2</sup>, `기본형 객체로 바꾸기`<sup>7.3</sup> 로 캡슐화 할 수 있고 리팩터링에 많은 문제가 임시 변수는 되는 부분은 `임시 변수를 질의 함수로 바꾸기`<sup>7.4</sup>  로 처리 가능하다고 한다.

클래스는 본래 정보를 숨기는 용도로 설계되었고 함수를 추출/인라인 하듯이 `클래스 추출하기`<sup>7.5</sup>와 `클래스 인라인하기`<sup>7.6</sup> 를 할 수 있다.

그 외에도 클래스는 내부 정보 뿐 아니라 클래스 사이의 연결 관계를 숨기는 데도 유용하므로 숨기는 방법인 `위임 숨기기`<sup>7.7</sup> 와 반대로 너무 많이 숨겨서 인터페이스가 비대해진 경우 사용할수 있는 `중개자 제가하기`<sup>7.8</sup>도 알아볼 수 있다.

가장 큰 캡슐화 단위는 모듈과 클래스 이지만 함수도 구현을 캡슐화 할 수 있다. 알고리즘을 통째로 바꿔야 할 경우 `알고리즘 교체하기`<sup>7.9</sup>를 적용하면 도움이 될 것이다.



## 7.1 레코드 캡슐화 하기

![image-20220105041319479](https://img.jimbae.com/images/9174aa32-a41b-48b7-8b8c-467c412add60/image-20220105041319479.png)

### 배경

대부분의 언어는 데이터 레코드를 표현하는 구조를 제공해 주고. 데이터를 직관적인 방법으로 묶을떄 훨씬더 의미있는 단위로 사용할 수 있다.

가변 데이터의 경우 레코드 보다는 객체를,  불투명한 레코드는 클래스를 사용하는것이 좋다고 한다.



### 절차

1. 레코드를 담은 변수를 캡슐화 한다.

2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화 하는 함수들이 이 접근자를 사용하도록 수정한다.

3. 테스트 한다.

4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.

5. 레코드를 반환하는 예전 함수를 사용하는 코드를 위에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀떄 마다 테스트 한다.

6. 클래스에서 원본 데이터를 반환하는 접근자와, 원본 레코드를 반환하는 함수들을 제거한다.

7. 테스트 한다.

8. 레코드의 필드도 데이터 구조의 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화 하기를 제귀적으로 적용한다.



### 예시

### 1. 간단한 레코드 캡슐화 하기

프로그램에 널리 쓰이는 아래 레코드를 캡슐화 해보자

```json
const organization = {name: "애크미 구스베리", country: "GB"}
```

위의 레코드는 아래와 같이 사용 되고 있다.

```javascript
result += `<h1>{organization.name}</h1>`;
organization.name = newName;
```



`절차1` : 상수를 캡슐화 한다.

```javascript
function getRawDataOfOrganization(){return organization;}
```

```javascript
result += `<h1>${getRawDataOfOrganization().name</h1>`;
getRawDataOfOrganization().name = newName;
```



레코드를 캡슐화 하는 목적은 변수 자체는 물론 내용을 조작하는 방식을 통제하기 위해서다.  이렇게 하기 위해서,

`절차2`: 레코드를 캡슐화 하고, `절차4`: 새 클래스의 인스턴스를 반환하는 함수를 새로 만들자

> Organization Class

```javascript
class Organization {
    constructor(data){
        this._data = data;
    }
}
```

```javascript
const organization = new Organization({name: "애크미 구스베리", country: "GB"});
function getRawDataOfOrganization(){return organization._data;}
function getOrganization(){return organization;}
```



객체로 만드는 작업은 완료되었고 레코드를 사용하던 코드를 세터를 사용하도록 고친다. 

`절차5`: 레코드를 반환하는 예전 함수를 사용하는 코드를 새 함수를 사용하도록 바꾼다.

> Organization Class

```javascript
set name(aString) {this._data.name = aString;}
```

> 클라이언트

```javascript
getOrganization().name = newName;
```

레코드를 읽는 코드는 모두 게터를 사용하도록 변경.

> Organization Class

```javascript
get name() {return this._data.name;}
```

> 클라이언트

```javascript
result += `<h1>${getOrganization().name}</h1>`;
```



다 바꿧다면 `절차6`: 임시 함수를 제거 한다.

```javascript
//function getRawDataOfOrganization(){return organization._data;}
function getOrganization(){return organization;}
```



마지막으로 _data 필드들을 객체 안에 펼쳐 놓으면 더 좋다.

```jav
class Organization {
    constructor(data){
        this._name = data.name;
        this._country = data.country;
    }
    get name()			{return this._name;}
    set name(aString)	{this._name = aString;}
    get country()		{return this._country;}
    set country(aCountryCode) this._country = aCountryCode;}
}
```



### 2. 중첩된 레코드 캡슐화 하기

아래와 같이 복잡하게 중첩된 레코드를 캡슐화 하는 예시도 살펴보자.

```json
"1920": {
    name: "마틴 파울러",
    id: "1920",
    usages: {
        "2016": {
            "1": 50,
            "2": 55,
            ...
        },
        "2015": {
            "1": 70,
            "2": 63,
            ...
        }
    }
},
"38673": {
    name: "닐 포드",
    id: "38637",
    ....
}
```

위의 레코드를 사용할때 쓰기와 읽기의 예제를 살펴 보자.

> 쓰기

```javascript
customerData[customerID].usages[year][month] = amount; //끔찍하다
```

> 읽기

```javascript
function compareUsage(customerID, laterYear, month){
    const later = customerData[customerID].usages[laterYear][month];
    const earlier = customerData[customerID].usages[laterYear - 1][month];
    return {laterAmount: later, change: later - earlier;}
}
```



이번에도 `절차1` 캡슐화 부터 시작하자.

```javascript
function getRawDataOfCustomers() {return customerData;}
function setRawDataOfCustomers(arg) {customerData = arg;}
```

`절차2` 읽기와 쓰기 함수를 변경한다.

> 쓰기

```javascript
getRawDataOfCustomers()[customerID].usages[year][month] = amount; //끔찍하다
```

> 읽기

```javascript
function compareUsage(customerID, laterYear, month){
    const later = getRawDataOfCustomers()[customerID].usages[laterYear][month];
    const earlier = getRawDataOfCustomers()[customerID].usages[laterYear - 1][month];
    return {laterAmount: later, change: later - earlier;}
}
```



그런 다음 `절차4` 구조를 표현하는 클래스를 정의, 이를 반환하는 함수를 만든다.

```javascript
class CustomerData{
    constructor(data){
        this._data = data;
    }
}
```

> 최상위

```javascript
function getCustomerData() {return customerData;}
function getRawDataOfCustomers() {return customerData._data;}
function setRawDataOfCustomers(arg) {customerData = new CustomerData(arg);}
```



데이터 쓰기의 경우 데이터 구조 안으로 들어가서 값을 변경하는 상황이므로 우선적으로 세터로 뽑아내는 작업 부터 한다.

> 쓰기 함수 추출

```javascript
setUsage(customerID, year, month amount);
```

> 최상위

```javascript
function setUsage(customerID, year, month amount){
	customerData[customerID].usages[year][month] = amount; 
}
```

그런 다음 이 함수를 고객 데이터 클래스로 옮긴다.

> 변경후 쓰기 예

```javascript
getCustomerData().setUsage(customerID, year, month, amount);
```



읽기도 동일하게 독립 함수로 추출후 고객 데이터 클래스로 옮길수 있다.

> CustomerData 클래스

```javascript
usage(customerID, year, month){
    return this._data[customerID].usage[year][month];
}
```

> 최상위

```javascript
function compareUsage(customerID, laterYear, month){
    const later = getCustomerData().usage(customerID, laterYear, month);
    const earlier = getCustomerData().usage(customerID, laterYear - 1, )
}
```

