# 9장 데이터 조직화

## 서문

* **변수 쪼개기<sup>9-1</sup> :** 하나의 값이 여러 목적으로 사용된다면 혼란과 버그를 낳으므로 용도별로 분리 할 필요가 있다.
* **변수 이름 바꾸기<sup>9-2</sup> : **변수의 이름을 제대로 짓는 일은 까다로우면서도 중요 하다.
* **파생 변수를 질의 함수로 바꾸기<sup>9-3</sup> : ** 변수 자체를 완전히 없애는 게 가장 좋은 해법일 때도 있다.
* **참조를 값으로 바꾸기<sup>9-4</sup>, 값을 참조로 바꾸기<sup>9-5</sup> : ** 참조인지 값인지 에 맞추어 둘 사이를 전환한다.



## 9.1 변수 쪼개기

![image-20220301160325849](https://img.jimbae.com/images/7a0420dd-f37d-4fdd-b63e-4fb2a7dee890/image-20220301160325849.png)



### 배경

값을 여러번 대입할 수 밖에 없는 경우의 함수도 있다.

반복문 안에 들어가는 `루프 변수`( *for(let i = 0; i < 10; i++)* 에서 변수 `i` )  혹은 메서드가 동작하는 중간중간 값을 저장하는 `수집 변수`

하지만 그 외의 변수는 아래의 법칙을 따른다.

* 변수에는 값을 단 한 번만 대입해야한다.
* 대입이 두 번 이상 이뤄진다면 여러 가지 역할을 수행한다는 신호다.
* 역할이 둘 이상인 변수가 있다면 쪼개야 한다. 예외 없이 역할 하나당 변수 하나다.
* 여러 용도로 쓰인 변수는 코드를 읽는 이에게 커다란 혼란을 주기 때문이다.



### 절차

1. 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다.
   * 대입이 항사 i = i + <무언가> 형태라면 수집 변수이므로 쪼개면 안된다. 
2. 가능하면 이때 불변으로 선언한다.
3. 이 변수에 두 번째로 값을 대입하는 곳 앞까지의 모든 참조(이 변수가 쓰인 곳)를 새로운 변수 이름으로 바꾼다.
4. 두 번째 대입 시 변수를 원래 이름으로 다시 선언한다.
5. 테스트한다.
6. 반복한다. 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다. 이 과정을 마지막 대입까지 반복한다.



## 9.2 필드 이름 바꾸기

![image-20220301164032625](https://img.jimbae.com/images/9b151598-cbd7-4b84-8217-7503c439cee0/image-20220301164032625.png)

### 배경

* 개발을 진행할수록 데이터를 더 잘 이해하게 된다. 따라서 그 깊어진 이해를 프로그램에 반드시 반영해야 하고, 이 과정에서 레코드의 필드 이름을 바꿔야 한다.
* 게터와 세터 메서드는 클래스 사용자 입장에서는 필드와 가를 바 없으므로 게터와 세터 이름 바꾸기도 구조체의 필드 이름 바꾸기와 동일하다.



## 9.3 파생 변수를 질의 함수로 바꾸기

![image-20220301190647287](https://img.jimbae.com/images/335b6592-7b50-4af4-9e50-564c242eff88/image-20220301190647287.png)

### 배경

* 가변 데이터는 자주 문제가 되곤 한다. (한쪽에서 값을 변경 할 경우 다른쪽에도 영향을 준다.)
* 가변 데이터를 완전히 배제하기는 힘들지만, 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다.
* 효과 좋은 방법중 한가지는 계산해낼 수 있는 변수들을 모두 제거 하는 것이다.
  * 계산 과정을 보여주는 코드 자체가 의미를 더 분명히 드러내 주기도 한다.
  * 변경된 값을 깜박하고 결과 변수에 반영하지 않는 실수를 막아 준다.
* 예외의 경우도 있다. 새로운 데이터 구조를 생성하는 변형 연산 이라면 그대로 두는 것도 좋다. *[솔직히 무슨말인지 모르겠다*.]
  * 첫째, 데이터 구조를 감싸며 그 데이터에 기초하여 계산한 결과를 속성으로 제공하는 객체
  * 둘째, 데이터 구조를 받아 다른 데이터 구조로 변환해 반환하는 함수



### 절차

1. 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다.
2. 해당 변수의 값을 계산해주는 함수를 만든다.
3. 해당 변수가 사용되는 모든곳에 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다.
   * 필요하다면 변수 캡슐화하기를 적용하여 어서션이 들어갈 장소를 마련해 준다.
4. 테스트한다.
5. 변수를 읽는 코드를 모두 함수 호출로 대체한다.
6. 테스트 한다.
7. 변수를 선언하고 갱신하는 코드를 죽은코드 제거하기로 없앤다.



## 9.4 참조를 값으로 바꾸기

![image-20220301193335879](https://img.jimbae.com/images/f0a5084e-593e-4788-a776-e33c03202f2d/image-20220301193335879.png)



### 배경

* 객체를 다른 객체에 중첩하면 내부 객체를 참조 혹은 값으로 취급할 수 있다.
* 참조냐 값이냐의 차이는 내부 객체의 속성 을 갱신하는 방식에서 차이가 난다.
  * 참조로 다루는 경우 내부 객체는 그대로 둔 채 그 객체의 속상만 갱신한다.
  * 값으로 다루는 경우에는 새로운 속성을 담은 객체로 기존 내부 객체를 통째로 대체한다.
* 만약 특정 객체를 여러 객체에 공유하고, 공유 객체의 값을 변경했을 때 이를 관련 객체 모두에 알려줘야 한다면 공유 객체를 참조로 바꿔야 한다.



### 절차

1. 후보 클래스가 불변인지 혹은 불변이 될 수 있는지 확인한다.
2. 각각의 세터를 하나씩 제거한다.
3. 이 값 객체의 필드들을 항상 동치성(equality) 비교 메소드를 만든다.



## 9.5 값을 참조로 바꾸기

![image-20220301210759546](https://img.jimbae.com/images/34ad342b-6585-4e38-aad9-17f8447a4856/image-20220301210759546.png)

### 배경

* 데이터를 값으로 다룬다면 데이터가 복사되고 해당 데이터를 갱신해야 할때 문제가 될 수 있다. 
  * 모든 복제본을 찾아서 빠짐없이 찾아서 갱신해야 하며, 하나라도 놓치면 데이터 일관성이 꺠져버린다.
  * 이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는 게 좋다.
* 값을 참조로 바꾸면 엔티티 하나당 객체도 단 하나만 존재하게 되므로 이런 객체들을 한테 모아놓고 클라이언트들의 접근을 관리해주는 저장소가 있으면 좋다.
  * 객체가 필요한 곳에서는 모두 이 저장소로 부터 얻어 쓰는 방식.



### 절차

1. 같은 부류에 속하는 객체들을 보관할 저장소를 만든다.
2. 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다.
3. 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 한다. 하나 수정할 떄마다 테스트 한다.



## 9.6 매직 리터러 바꾸기

상수를 쓰자.