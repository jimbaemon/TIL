# 쿠버네티스 핵심 개념

## 큐브 시스템 컴포넌트

### 1. 큐브 API 서버

* 쿠버네티스 시스템 컴포넌트는 오직 API 서버와 통신한다.
  * 컴포넌트끼리 서로 통신하는 일은 없다.
  * 컴포넌트끼리 서로 통신할때는 API 서버를 중계하여야 함
* RestfulAPI를 통해 클러스터 상태를 쿼리, 수정할 수 잇는 기능 제공
* API 서버의 구체적인 역활
  * 인증 플러그인을 사용한 클라이언트 인증
  * 권한 승인 플러그인을 통한 클라이언트 인증
  * 승인 제어 플러그인을 통해 요청 받은 리소스를 확인/수정
  * 리소스 검증 및 영구 저장



### 2. 큐브 컨트롤러 매니저

* 컨트롤러에는 다양한 컨트롤러가 존재
* API에 의해 받아진 요청을 처리하는 역활
  * 레플리케이션 매너저
  * 레플리카셋, 데몬셋, 잡 컨트롤러
  * 디플로이먼트 컨트롤러
  * ...



### 3. 큐브 스케줄러

* 일반적으로 실행할 노드를 직접 정해주지 않음
* 요청 받은 리소스를 어느 노드에 실행할지 경정하는 역활
* 현재 노드의 상태를 점검하고 최상의 노드를 찾아 배치
* 다수의 포드를 배치하는 경우에는 `라운드로빈`을 사용하여 분산



## 큐브시스템에서 사용하는 포드 확인

```bash
kubectl get pod -n kube-system
```

**실행결과**

![image-20210220212811518](http://www.jimbae.com:59005/image/154)



## 큐브시스템 설정 변경법

* `/etc/kubernetes/manifests/` 하위의 `.yml` 파일의 설정을 변경하면 된다.





## ETCD 데이터베이스 살펴보기

* etcd 는 쿠버네티스에서 사용 하는 Open Source 데이터베이스 이다.
* Key-Value Set 기반 데이터베이스

**![image-20210221211938033](http://www.jimbae.com:59005/image/155)**



### 쿠버네티스 - ETCD 데이터베이스 키 구조

![image-20210221220534755](http://www.jimbae.com:59005/image/156)



### 직접 ETCD 사용해보기

> 깃허브 주소 : https://github.com/etcd-io/etcd/releases

```bash
wget https://github.com/etcd-io/etcd/releases/download/v3.4.14/etcd-v3.4.14-linux-amd64.tar.gz #다운로드
tar -xf etcd-v3.4.14-linux-amd64.tar.gz #압축풀기
cd ./etcd-v3.4.14-linux-amd64 #폴더안에 etcdctl 명령어 존재
sudo ETCDCTL_API=3 ./etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key get / --prefix --keys-only #ETCD 내장 내용 확인
```



**데이터 입출력 예제**

```bash
sudo ETCDCTL_API=3 ./etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key put key1 value1 #key1 value1 입력
sudo ETCDCTL_API=3 ./etcdctl --endpoints 127.0.0.1:2379 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key get key1  #key1 cnffur
```





## POD 소개

* 쿠버네티스에서의 기본 빌딩
* 팟은 하나의 노드에서 실행된다.



**장점**

* 밀접하게 연관된 프로세스를 함께 실행하고, 하나의 환경에서 동작하는 것처럼 보인다.
* 다소 격리된 상태로 유지 가능
  * 포드의 모든 컨테이너는 동일한 네트워크 및 UTS 네임스페이스에서 실행
  * 같은 호스트명 및 네트워크 인터페이스를 공유하므로 포트 충돌 가능성 있음



#### 포드 네트워크

* 쿠버네티스 클러스터의 모든 포드는 공유된 단일 플랫, 네트워크 주소 공간에 위치한다. [이미지 참조]
* 포드 사이에 NAT 게이트웨이가 존재하지는 않는다 [서로 통신은 되지만 NAT 게이트웨이 같지는 않다는 의미인듯 하다.]

![image-20210222204452781](http://www.jimbae.com:59005/image/162)



#### 컨테이너를 포드 전체에 적절하게 구성하는 방법

* 다수의 포드로 멀티티어로 어플리케이션 분할 필요함
* 각각 스케일링이 가능한 포드로 분할한다.

![image-20210222204803817](http://www.jimbae.com:59005/image/163)



#### 포드 정의

* 포드 정의 구성요소
  * apiVersion: 쿠버네티스 api의 버전
  * kind: 어떤 리소스 유형인지 결정[포드, 레플리카컨트롤러, 서비스 등]
  * 메타데이터: 포드와 관련된 이름, 네임스페이스 , 라벨, 그 밖의 정보 존재
  * 스펙: 컨테이너, 볼륨 등의 정보
  * 상태: 포드의 상태, 각 컨테이너의 설명 및 상태, 포드 내부의 IP 및 그 밖의 기본 정보 등





## 포드 디스크럽터 작성해보기

> https://kubernetes.io/docs/concepts/workloads/pods/



```bash
cd ~ #홈 디렉토리로 이동
mkdir yaml #yaml 설정 파일 저장할 폴더 생성
cd yaml
vim go-http-pod.yaml #yaml 생성
```



**go-http-pod.yaml**

```yaml
apiVersion: v1
kind: Pod
metadata:
    name: http-go
spec:
    containers: #컨테이너 정보
    - name: http-go
      image: jimbae/http_go #docker hub 의 리포지토리 명
      ports:
      - containerPort: 8080
```

**포드 생성/확인**

```bash
kubectl create -f go-http-pod.yaml
kubectl get pod http-go -o yaml #yaml 형식으로 정보 상세보기 혹은 kubectl describe pod http-go 로도 확인 가능
```



**포드 삭제**

```bash
kubectl delete -f go-http-pod.yaml #또는
kubectl delete pod http-go
```



## 포드 실습 해보기

#### 연습문제

* 모든 리소스 삭제
* YAML을 사용하여 도커이미지 jenkins로 Jenkins-manual 포드를 생성하기
* Jenkins 포드에서 curl 명령어로 로컬호스트:8080 접속하기
* Jenkins 포트를 8888 로 포트 포워딩 하기
* 현재 Jenkins-manual의 설정을 yaml로 출력하기



**풀이**

```bash
kubectl delete pods --all #모드 포드 제거
vim jenkins-manual-pod.yaml #jenkins manual 포드 생성용 yaml 생성
kubectl create -f jenkins-manual-pod.yaml #jenkins manual pod 생성
kubectl exec jenkins-manual -- curl -s localhost:8080 #curl 로 테스트
kubectl port-forward jenkins-manual 8888:8080 # 포트포워딩
kubectl get pod jenkins-manual -o yaml #yaml 형태로 출력
kubectl logs jenkins-manual #logs 출력
```



**jenkins-manual-pod.yaml**

```yaml
apiVersion: v1
kind: Pod
metadata:
    name: jenkins-manual
spec:
    containers: #컨테이너 정보
    - name: jenkins-manual
      image: jenkins:2.60.3
      ports:
      - containerPort: 8080
```



## POD의 라이브네스, 레드네스, 스타트업 프로브

* **Liveness Probe**
  * 컨테이너가 살았는지 판단하고, 아니면 다시시작하는 기능
  * 컨테이너의 상태를 스스로 판단하여 교착 상태에 빠진 컨테이너를 재시작
  * 버그가 생겨도 높은 가용성을 보임
* **Readiness Probe**
  * 포드가 준비된 상태에 있는지 확인하고 정상 서비스를 시작하는 기능
  * 포드가 적절하게 준비되지 않은 경우 로드밸런싱을 하지 않음
* **Startup Probe**
  * 애플리케이션의 시작 시기 확인하여 가용성을 높이는 기능
  * Liveness와 Readiness의 기능을 비활성화 하여 컨테이너 시작을 도움



#### 내용 실습

* https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/ **[쿠버네티스 도큐맨테이션 참고]**

* **Liveness 커맨드**

  * 리눅스 환경에서 커맨드 실행 성공시 0
  * 리눅스 환경에서 커맨드 실행 실패시 기타값 -> 포드 재시작

* **Liveness 웹 설정 - http 요청 확인**

  * 서버 응답 코드가 200 이상 400 미만시 성공
  * 응답코드가 200이상 400미만이 아닐시 실패 -> 포드 재시작
    

  ##### LIVENESS 예제

  ```bash
  vim exec-liveness.yaml #Liveness 테스트용 yaml 생성
  kubectl create -f exec-liveness.yaml #실행하기
  kubectl describe pod liveness-exec #상태확인
  ```

  

  **exec-liveness.yaml [도큐맨테이션 중간에 확인가능]**

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    labels:
      test: liveness
    name: liveness-exec
  spec:
    containers:
    - name: liveness
      image: k8s.gcr.io/busybox
      args:
      - /bin/sh
      - -c
      - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
      livenessProbe:
        exec:
          command:
          - cat
          - /tmp/healthy
        initialDelaySeconds: 5
        periodSeconds: 5
  ```


  **LivenessProbe 결과 /tmp/healthy 가 응답 없음으로 killing 이 동작한것을 확인 가능**

  ![image-20210225173724069](http://www.jimbae.com:59005/image/165)



​		**LivenessProbe 로 인해 재시작이 여러차례 되었음을 확인 가능**

​		![image-20210225174048795](http://www.jimbae.com:59005/image/168) 



​		**LivenessProbe 로 인해 재시작이 여러차례 진행되었음을 describe 로 확인 가능**	

​		![image-20210225174240395](http://www.jimbae.com:59005/image/170)



​		**Liveness http 예제 [500] 이 나올시 재시작**

* ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    labels:
      test: liveness
    name: liveness-http
  spec:
    containers:
    - name: liveness
      image: k8s.gcr.io/liveness
      args:
      - /server
      livenessProbe:
        httpGet:
          path: /healthz
          port: 8080
          httpHeaders:
          - name: Custom-Header
            value: Awesome
        initialDelaySeconds: 3
        periodSeconds: 3
  ```

  

  **10초 전에는 200 10초 이후에는 500이 나오는 통신**

  ```go
  http.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
      duration := time.Now().Sub(started)
      if duration.Seconds() > 10 {
          w.WriteHeader(500)
          w.Write([]byte(fmt.Sprintf("error: %v", duration.Seconds())))
      } else {
          w.WriteHeader(200)
          w.Write([]byte("ok"))
      }
  })
  ```


  ```bash
  kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml #위의 예제 실행
  ```

  

  **10초가 지나 Status code 500 이 나오고 재시작 되는 모습**

  ![image-20210225181423646](http://www.jimbae.com:59005/image/171)



* **Readiness 는 로드밸런싱 상황에서 확인해야 하므로 추후에 예제 추가한다.**