# 쿠버네티스 기초

## 쿠버네티스 소개

* 구글은 내부에 서비스를 관리하기 위해 `보그` 와 `오메가` 라는 내부 오케스트레이션 프로그램을 가지고 있었음
* 2014년에 구글은 위의 프로그램을 통해 얻은 경험을 바탕으로 `쿠버네티스`를 출시



### 인프라의 추상화

* 컨테이너 시스템에서 컨테이너 애플리케이션을 쉽게 배포, 관리하도록 돕는 소프트웨어 시스템
* 기본 인프라를 추사오하해 개발 및 운영 팀의 개발, 배포, 관리를 단순화
* 모든 노드가 하나의 거대한 컴퓨터인 것처럼 수천개의 컴퓨터 노드에서 소프트웨어 애플리케이션을 실행

![image-20210211191834675](http://www.jimbae.com:59005/image/110)

### 쿠버네티스의 장점

* **애플리케이션 배포 단순화**
  * 특정 베어메탈을 필요로 하는 경우 (예: SSD/HDD) <sup>***베어메탈** : 그냥 하드웨어를 지칭</sup> 지정한 규칙에 맞게 배포하면, 자동으로 원하는 조건으로 배포된다.
* **하드웨어 활용도 극대화**
  * 클러스터의 주변에 자유롭게 이동하여 실행중인 당양한 애플리케이션 구성 요소를 클러스터 노드의 가용 리소스에 최대한 맞춰 서로 섞고 매치
  * 노드의 하드웨어 리소스를 최상으로 활용
* **상태 확인 및 자가 치유**
  * 애플리케이션 구성 요소와 실행되는 노드를 모니터링 하고 노드 장애 발생시 다른 노드로 일정을 자동으로 재조정
  * 운영자는 정규 근무 시간에만 장애가 발생한 노드를 처리
* **오토스케일링**
  * 개발 애플리케이션의 부하를 지속적으로 모니터링 할 필요 없다.
    * 자동으로 리소스를 모니터링
    * 각 애플리케이션에서 실행되는 인스턴스 수를 계속 조정하도록 지시 가능
* **애플리케이션 개발 단순화**
  * 버그 발견 및 수정 (완전히 개발환경과 같은 환경을 제공하기 때문)
  * 새로운 버전 출시 시 자동으로 테스트, 이상 발견 시 롤 아웃



### 쿠버네티스 역활

* **개발자 돕기 : 핵심 애플리케이션 기능에 집중**
  * 애플리케이션 개발자가 특정 인프라 관련 서비스를 애플리케이션에 구현하지 않아도 됨
  * 쿠버네티스에 의존해 서비스 제공
    * 서비스 검색, 확장, 로드 밸런싱, 자가 치유, 리더 선출 등
  * 애플레키이션 개발자는 애플리케이션의 실제 기능을 구현하는 데 주력
  * 인프라와 인프라를 통합하는 방법을 파악하는데 시간을 낭비할 필요 없음
* **운영 팀 돕기 : 효과적으로 리소스를 활용**
  * 실행을 유지하고 서로 통신할 수 있도록  컴포넌트에 정보를 제공
  * 애플리케이션이 어떤 노드에서 실행되든 상관 없음
  * 언제든지 애플리케이션을 재배치 가능
  * 애플리케이션을 혼합하고 매칭시킴으로써 리소스를 매칭





## 쿠버네티스 아키텍처

### 쿠버네티스 클러스터 아키텍처

* 쿠버네티스의 클러스터는 하드웨어 수준에서 많은 노드로 구성되며 두 가지 유형 나뉨
  * **마스터 노드** :  전체 쿠버네티스 시스템을 관리하고 통제하는 쿠버네티스 컨트롤 플레이을 관장
    * **kube-apiserver** :  사용자 인증, 모든 통신들의 역활을 한다.
    * **etcd** : kube-apiserver 가 데이터를 저장, 관리
    * **Controller-manager** : 쿠버네티스와 관련된 리소스를 관리할지를 제어 해주는 역활
    * **kube-scheduler** : 어떤 워크노드에 어떤 컨테이너가 배치될지를 정해주는 역활
  * **워커 노드** : 실제 배포하고자 하는 애플리케이션의 실행을 담당
    * **kubelet** : 도커의 런타임을 배치하는 역활
    * **kube-proxy** : 프록시 역활, 노드들과의 통신등을 이어주는 역활

![image-20210211195820467](http://www.jimbae.com:59005/image/113)

### 컨트롤 플레인 [마스터]

* 클러스터를 관리하는 기능
* 마스터 노드에서 실행하거나 여러 노드에서 분할되고 복제되 고 가용성을 보장
* 클러스터의 상태를 유지하고 제어하지만 애플리케이션을 실행하진 않음 [실행할수도 있다]



### 워커 노드

* 컨테이너화된 애플리케이션을 실행하는 시스템



![image-20210211200440327](http://www.jimbae.com:59005/image/114)



### 쿠버네티스에서 애플리케이션 실행 방법

* **쿠버네티스에서 애플리케이션을 실행 전** 
  * 하나 이상의 컨테이너 이미지들을 패키지로 레지스터리에 푸시
  * 쿠버네티스 API 서버에 애플리케이션의 디스크립션을 게시
* **디스크립션(YAML로 작성)**
  * 컨테이너 이미지 또는 애플리케이션 컴포넌트가 들어 있는 이미지가 존재
  * 컴포넌트 간 관련성 및 노드 배치 (동일 노드 또는 다른 노드) 정보 포함
  * 각 컴포넌트의 실행 복제본 수를 지정
  * 내부 클라이언트나 외부 클라이언트에 서비스를 제공하는 컴포넌트
  * 단일 IP 주소로 노출해 다른 컴포넌트에서 검색

![image-20210211201419106](http://www.jimbae.com:59005/image/115)



## 우분투에 크버네티스 클러스터 구성

* **Master 우분투 : **Kubernetes 의 마스터 노드가 설정될 호스트
* **Work 노드 (옵션) : **필수 사항은 아니지만, 클러스터에 Work 노드 추가 학습



* 버추얼박스에서 각 노드에서 복제하면서 반드시 **변경**해야 하는 설정
  * 호스트 이름 : /etc/hostname [노드를 host 명으로 구분한다.]
  * 네트워크 인터페이스 변경 [MAC 주소] <sup>***같은 네트워크에 있으면 2계층 통신을 한다.**</sup>
  * NAT 네트워크 설정
  * (호스트 이름 변경시 재시작)



### 우분투에 쿠버네티스 설치

* 아래의 내용을 install.sh 파일에 작성하고 chmod로 권한을 주고 실행

```bash
# install.sh
sudo apt-get update && sudo apt-get install -y apt-transport-https curl
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
cat <<EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
deb https://apt.kubernetes.io/ kubernetes-xenial main
EOF
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
```



**Kubernetes 를 관리하는 명령어**

* **kubeadm**
  * 클러스터를 부트스랩하는 명령
* **kubelet**
  * 클러스터의 모든 시스템에서 실행되는 구성 요소로, 창 및 컨테이너 시작과 같은 작업을 수행
* **kubectl**
  * 커맨드 라인 util은 당신의 클러스터와 대화



### Master 노드 초기화 (마스터 노드에서만 할 것!)

* Master 노드 초기화를 위해 가장 먼저 수행 (사용할 Pod 네트워크 대역 설정)

```bash 
sudo kubeadm init
```



* **스왑 에러 발생시 스왑 기능 제거**

```bash
sudo swapoff -a #현재 커널에서 스왑기능 끄기 (리붓시 초기화)
sudo sed -i `/swap / s/^\(.*\)$/#\1/g` /etc/fstab #리붓하더라도 스왑 비활성화 기능 유지
reboot
```

> 스왑 기능 제거 이유
>
> * Kubernetes 1.8 이후, 노드에서 스왑을 비활성화 하지 않으면 오류 발생 (--fail-wap-on 을 false 로 하면 오류는 미발생) 하는데 그 이유는 아래와 같다.  
>   리눅스의 Swap 기능은 메모리가 부족할시 시스템 하드 디스크 일부 공간을 활용하는 대신 성능이 떨어지게 되는데, Kubernetes의 아이디어는 인스턴스를 최대한 100% 에 가깝에 성능을 발휘하도록 하는 것이고 인스턴스의 메모리가 부족할시 다른 여유가 있는 인스턴스를 사용하는것이 목적이다.
>   하지만 Swap 기능을 통한 성능을 포기한 메모리 확장은 이러한 정신과 맞지 않기 때문에  비활성화 하지 않으면 오류가 발생한다.



#### 클러스터 사용 초기 세팅(마스터 노드에서만 할 것!)

* 다음을 일반 사용자 계정으로 실행 (init시 콘솔에 출력된 메시지를 복붙)

```bash
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
```



* Pod Network 추가

```bash
kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"
```



### 워커 노드 추가 (워커 노드에서만 할 것!)

* 앞서 설치한 대로 쿠버네티스 설치
* init 명령어 전까지만 수행(init 금지)
* 이후 각 노드에서 관리자 권한으로 워커 노드를 참가 시킴 (init 시 콘솔에 출력된 메시지를 복붙)

```bash
sudo kubeadm join 10.0.2.15:6443 --token [토큰] \ --discoery-tokene-ca-cert-hash [해시]
```



#### 연결된 노드들의 상태 확인

```bash
kubectl get nodes #Status 값이 NotReady 상태인 경우, Pod Network가 아직 deploy 되기 전일수 있음, 장시간 안될시 Pod Network 추가 오류
```



#### 일반적인 사용자와 마스터 노드, 워커 노드 연결 관계

![image-20210212145947958](http://www.jimbae.com:59005/image/116)



#### VB를 이용한 마스터 노드, 워커 노드 연결 관계

> 일반적으로는 kubectl 을 외부에 둬서 마스터 노드의 Rest API 서버와 통신만을 함

![image-20210212150054472](http://www.jimbae.com:59005/image/117)